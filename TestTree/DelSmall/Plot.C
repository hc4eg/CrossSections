#include <iostream>
#include <fstream>
#include <stdio.h>
#include <sstream>
#include <string>
#include <iomanip>

// Headers from ROOT
#include <TCanvas.h>
#include <TGraph.h>
#include <TObject.h>

using namespace std;

// This file is used to generate asymmetry plots by using BH_cross_section code
// Under certain Theta (Theta = Theta_q = Theta_p) and Phi (Phi_q - Phi_p), 
// over a certain range of Delta (E_q - E_p) total cross section, symmetric part of
// cross section, asymmetric part of cross section, and asymmetry are computed and 
// stored in data files with name like Xsec.run%3d.dat.

// Plot.C then use data from those files to plot ROOT TGraph on all computed quantities
// To use it:
// 1. Copy/ move data files generated by ./OutTxt under /TestTree directory into this directory.
// 2. Type "root"
// 3. In ROOT, type ".L Plot.C+", then "AsymPlot()"
// 4. Follow the pop out message, type full data file name.
// 5. TGraph plots will be generated.

double FindString(vector<string> Info, string Str, int size);

void AsymPlot(){
	string FileName;
	cerr << "Please type file name: (format:  Xsec.run%3d.dat)" << endl;
	cin >> FileName;

	// Code prevent incorrect filename input:
	ifstream InFile(FileName.c_str());
	while(InFile.fail()){
		InFile.clear();
		cout << "File not found:  " << FileName << endl;
		cout << "Please enter new name" << endl;
		getline(cin, FileName);
		cin.ignore(1, '\n');
		InFile.open(FileName.c_str());
	}	

	// Find out Theta Phi and NPts by parsing the 1st line
	Int_t Npts;
	Double_t Theta;
	Double_t Phi;
	vector<string> Info;
	Info.resize(3);
	vector<string> Str;
	Str.push_back("Npts=");
	Str.push_back("Theta=");
	Str.push_back("Phi=");


	// FIXME:  why '\t' won't stop at multiple spaces?
	//getline(InFile, Info.at(0), '\t');
	//cerr << Info.at(0);
	
	for (Int_t i = 0; i < 3; i++){
		//getline(InFile, Info.at(i), '\t');
		InFile >> Info.at(i);
		//cerr << Info.at(i);
	}
	cerr << endl;

	
	Npts = (Int_t)FindString(Info, Str.at(0), 3);
	Theta = FindString(Info, Str.at(1), 3);
	Phi = FindString(Info, Str.at(2), 3);

	string ALine;
	// Skip the rest of 1st line and 2nd line
	getline(InFile, ALine , '\n');
	getline(InFile, ALine, '\n');
	//InFile.ignore(200, '\n');
	//InFile.ignore(200, '\n');
	cerr << "Number of points: " << Npts << ", Theta: " << Theta << ", Phi: " << Phi << endl;



	// Now read all data and put them in arrays
	double Del[Npts];
	double Xsec[4][Npts];

	for(int i = 0; i < Npts; i++){
		Del[i] = 0.;
		for(int j = 0; j < 4; j++){
			Xsec[j][i] = 0.;
		}
	}

	//cout << setw(20) << "Del" << setw(20) << "Xsec" << setw(20) << "Xsec_s" << setw(20) << "Xsec_a" <<  setw(20) << "Asymmetry" << endl;
	vector<string> Data;
	Data.resize(5);
	//cerr << "Initial data: " << endl;
	//cerr << Data.at(0) << endl;

	for(Int_t i = 0; i < Npts; i++){
		//Read a line's all 5 data into vector Data 
		for(Int_t j = 0; j < 5; j++){
			InFile >> Data.at(j);
			//cerr << "   " << j << "th data is "<< setw(20) << Data.at(j);
		}
		//cerr << endl;
		
		// Convert elements of Data (string) into array Del[] and Xsec[][]
		Del[i] = atof(Data.at(0).c_str());
		for(Int_t j = 1; j < 5; j++){
			Xsec[j-1][i] = atof(Data.at(j).c_str());
		}
		InFile.ignore(200, '\n');

		//cout << setw(20) << Del[i] << setw(20) << Xsec[0][i] << setw(20) << Xsec[1][i] << setw(20) << Xsec[2][i] <<  setw(20) << Xsec[3][i] << endl;
	}

	// Plot all functions in TGraph
	TCanvas* C_Xsec = new TCanvas("C_Xsec", Form("Xsec plots and Asymmery plot at Theta = %f, Phi = %f, with Npts = %d", Theta, Phi, Npts), 1600, 1200);
	C_Xsec->Divide(2,2);

	// Assign titles for TGraph
	vector<string> Title;
	Title.push_back("Cross section");
	Title.push_back("Symmetry part of cross section");
	Title.push_back("Asymmtry part of cross section");
	Title.push_back("Asymmetry");

	vector<TGraph*> G_Xsec;
	for( Int_t i = 0; i < 4; i++){
		G_Xsec.push_back(new TGraph((Int_t)Npts, (Double_t*)Del, (Double_t*)Xsec[i]));
		G_Xsec.at(i)->SetTitle(Title.at(i).c_str());
		C_Xsec->cd(i+1);
		G_Xsec.at(i)->Draw();
	}
}

double FindString(vector<string> Info,
		  string Str, 
		  int Size)
{
		size_t Found;	
		double Value = 0;
		for(int i = 0; i < Size ; i++ ){
			if( Info.at(i).find(Str) != string::npos ){
				Found = Info.at(i).find(Str);
				Info.at(i).erase(0, Found+Str.size());
				Value = atof(Info[i].c_str());
			}
		}

		if (Value != 0.)
			return Value;
		else {
			cerr << "String not found, return 0." << endl;
			return 0;
		}
}
